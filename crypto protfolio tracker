import React, { useState, useEffect, useMemo } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from 'firebase/auth';
import { getFirestore, doc, onSnapshot, setDoc } from 'firebase/firestore';

// --- Helper Components ---

const StatCard = ({ title, value, change, isCurrency = true }) => (
    <div className="bg-gray-800/50 backdrop-blur-sm p-6 rounded-2xl shadow-lg border border-gray-700">
        <h3 className="text-sm font-medium text-gray-400">{title}</h3>
        <p className={`text-2xl lg:text-3xl font-bold mt-2 ${!change ? 'text-white' : ''}`}>
            {isCurrency && '$'}{value}
        </p>
        {change && (
            <p className={`text-sm font-semibold mt-1 ${change.value >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                {change.value >= 0 ? '▲' : '▼'} {change.value.toFixed(2)}%
            </p>
        )}
    </div>
);

const TransactionModal = ({ isOpen, onClose, coins, onAddTransaction }) => {
    const [error, setError] = useState('');
    if (!isOpen) return null;

    const handleSubmit = (e) => {
        e.preventDefault();
        setError(''); // Reset error on new submission
        const formData = new FormData(e.target);
        const transaction = {
            coinId: formData.get('coin'),
            quantity: parseFloat(formData.get('quantity')),
            price: parseFloat(formData.get('price')),
        };
        
        const selectedOption = e.target.coin.options[e.target.coin.selectedIndex].text;
        const match = selectedOption.match(/(.*) \((.*)\)/);
        if (match) {
            transaction.name = match[1];
            transaction.symbol = match[2];
        }

        if (transaction.coinId && !isNaN(transaction.quantity) && transaction.quantity > 0 && !isNaN(transaction.price) && transaction.price >= 0) {
            onAddTransaction(transaction);
        } else {
            // Basic validation feedback
            setError("Please fill out all fields with valid data.");
        }
    };

    return (
        <div className="fixed inset-0 bg-black bg-opacity-70 z-50 flex justify-center items-center p-4 transition-opacity duration-300">
            <div className="bg-gray-800 rounded-2xl shadow-2xl p-8 w-full max-w-md border border-gray-700 transform transition-all duration-300 scale-100">
                <div className="flex justify-between items-center mb-6">
                    <h2 className="text-2xl font-bold text-white">Add Transaction</h2>
                    <button onClick={onClose} className="text-gray-400 hover:text-white text-2xl">&times;</button>
                </div>
                <form onSubmit={handleSubmit}>
                    <div className="mb-4">
                        <label htmlFor="coin" className="block text-sm font-medium text-gray-300 mb-2">Cryptocurrency</label>
                        <select id="coin" name="coin" required className="w-full bg-gray-700 border border-gray-600 text-white rounded-lg p-3 focus:ring-indigo-500 focus:border-indigo-500">
                            <option value="">Select a coin</option>
                            {coins.map(coin => (
                                <option key={coin.id} value={coin.id}>
                                    {`${coin.name} (${coin.symbol.toUpperCase()})`}
                                </option>
                            ))}
                        </select>
                    </div>
                    <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6">
                        <div>
                            <label htmlFor="quantity" className="block text-sm font-medium text-gray-300 mb-2">Quantity</label>
                            <input type="number" id="quantity" name="quantity" step="any" required className="w-full bg-gray-700 border border-gray-600 text-white rounded-lg p-3 focus:ring-indigo-500 focus:border-indigo-500" placeholder="e.g., 0.5" />
                        </div>
                        <div>
                            <label htmlFor="price" className="block text-sm font-medium text-gray-300 mb-2">Price Per Coin (USD)</label>
                            <input type="number" id="price" name="price" step="any" required className="w-full bg-gray-700 border border-gray-600 text-white rounded-lg p-3 focus:ring-indigo-500 focus:border-indigo-500" placeholder="e.g., 50000" />
                        </div>
                    </div>
                    {error && <p className="text-red-400 text-sm text-center mb-4">{error}</p>}
                    <button type="submit" className="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-3 px-4 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105">
                        Add to Portfolio
                    </button>
                </form>
            </div>
        </div>
    );
};


// --- Main App Component ---

export default function App() {
    // --- State Management ---
    const [portfolio, setPortfolio] = useState({});
    const [liveData, setLiveData] = useState({});
    const [coinList, setCoinList] = useState([]);
    const [isModalOpen, setIsModalOpen] = useState(false);
    const [isLoading, setIsLoading] = useState(true);
    const [userId, setUserId] = useState(null);
    const [db, setDb] = useState(null);
    const [lastUpdated, setLastUpdated] = useState('N/A');

    // --- Firebase Initialization and Auth ---
    useEffect(() => {
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : { apiKey: "YOUR_API_KEY", authDomain: "YOUR_AUTH_DOMAIN", projectId: "YOUR_PROJECT_ID" };
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        setDb(getFirestore(app));

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                setUserId(user.uid);
            } else {
                try {
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } else {
                        await signInAnonymously(auth);
                    }
                } catch (error) {
                    console.error("Authentication failed:", error);
                }
            }
        });
    }, []);

    // --- Firestore Data Sync ---
    useEffect(() => {
        if (!userId || !db) return;
        
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-crypto-tracker';
        const portfolioDocRef = doc(db, 'artifacts', appId, 'users', userId, 'portfolio', 'assets');
        
        const unsubscribe = onSnapshot(portfolioDocRef, (doc) => {
            if (doc.exists()) {
                setPortfolio(doc.data());
            } else {
                // Create the document if it doesn't exist
                setDoc(portfolioDocRef, {});
            }
            setIsLoading(false);
        }, (error) => {
            console.error("Error listening to portfolio:", error);
            setIsLoading(false);
        });

        return () => unsubscribe(); // Cleanup listener on unmount
    }, [userId, db]);
    
    // --- CoinGecko API Fetching ---
    useEffect(() => {
        // Fetch the master list of all coins for the modal
        const fetchCoinList = async () => {
            try {
                const response = await fetch('https://api.coingecko.com/api/v3/coins/list');
                const data = await response.json();
                setCoinList(data);
            } catch (error) {
                console.error('Error fetching coin list:', error);
            }
        };
        fetchCoinList();
    }, []);

    useEffect(() => {
        // Fetch live market data for coins in the portfolio
        const fetchMarketData = async () => {
            const coinIds = Object.keys(portfolio);
            if (coinIds.length === 0) {
                setLiveData({});
                return;
            };

            try {
                const url = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${coinIds.join(',')}`;
                const response = await fetch(url);
                const data = await response.json();
                const dataMap = data.reduce((acc, coin) => {
                    acc[coin.id] = coin;
                    return acc;
                }, {});
                setLiveData(dataMap);
                setLastUpdated(new Date().toLocaleTimeString());
            } catch (error) {
                console.error("Error fetching coin market data:", error);
            }
        };
        
        fetchMarketData();
        const interval = setInterval(fetchMarketData, 60000); // Refresh every 60 seconds
        return () => clearInterval(interval);

    }, [portfolio]);


    // --- Portfolio Calculations ---
    const portfolioStats = useMemo(() => {
        let totalValue = 0;
        let totalValue24hAgo = 0;
        let topGainer = { name: 'N/A', change: -Infinity };
        
        Object.values(portfolio).forEach(asset => {
            const data = liveData[asset.id];
            if (!data) return;

            const currentValue = asset.quantity * data.current_price;
            const value24hAgo = asset.quantity * (data.current_price - data.price_change_24h);
            
            totalValue += currentValue;
            totalValue24hAgo += value24hAgo;
            
            const change24h = data.price_change_percentage_24h || 0;
            if (change24h > topGainer.change) {
                topGainer = { name: data.name, change: change24h };
            }
        });
        
        const totalChangeValue = totalValue - totalValue24hAgo;
        const totalChangePercentage = totalValue24hAgo > 0 ? (totalChangeValue / totalValue24hAgo) * 100 : 0;

        return {
            totalValue,
            totalChangePercentage,
            topGainer
        };
    }, [portfolio, liveData]);


    // --- Event Handlers ---
    const handleAddTransaction = async (transaction) => {
        if (!userId || !db) return;
        
        const { coinId, quantity, price, name, symbol } = transaction;
        const newPortfolio = JSON.parse(JSON.stringify(portfolio)); // Deep copy

        if (newPortfolio[coinId]) {
            newPortfolio[coinId].quantity += quantity;
            newPortfolio[coinId].totalCost += quantity * price;
        } else {
            newPortfolio[coinId] = {
                id: coinId,
                name,
                symbol: symbol.toLowerCase(),
                quantity,
                totalCost: quantity * price,
            };
        }
        
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-crypto-tracker';
        const portfolioDocRef = doc(db, 'artifacts', appId, 'users', userId, 'portfolio', 'assets');
        try {
            await setDoc(portfolioDocRef, newPortfolio);
            setIsModalOpen(false);
        } catch (error) {
            console.error("Error adding transaction: ", error);
        }
    };

    const handleAddSamplePortfolio = async () => {
        if (!userId || !db) return;

        const sampleCoins = {
            'bitcoin': { name: 'Bitcoin', symbol: 'btc', quantity: 1 },
            'solana': { name: 'Solana', symbol: 'sol', quantity: 5 },
            'ethereum': { name: 'Ethereum', symbol: 'eth', quantity: 2 },
            'sui': { name: 'Sui', symbol: 'sui', quantity: 100 },
            'the-open-network': { name: 'Toncoin', symbol: 'ton', quantity: 50 },
            'binancecoin': { name: 'BNB', symbol: 'bnb', quantity: 3 },
        };

        const coinIds = Object.keys(sampleCoins);

        try {
            const url = `https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${coinIds.join(',')}`;
            const response = await fetch(url);
            const data = await response.json();
            
            if (!data || data.length === 0) {
                console.error("Could not fetch sample coin data.");
                return;
            }

            const newAssets = {};
            data.forEach(coin => {
                const sampleInfo = sampleCoins[coin.id];
                newAssets[coin.id] = {
                    id: coin.id,
                    name: sampleInfo.name,
                    symbol: sampleInfo.symbol,
                    quantity: sampleInfo.quantity,
                    totalCost: sampleInfo.quantity * coin.current_price,
                };
            });

            const newPortfolio = { ...portfolio, ...newAssets };

            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-crypto-tracker';
            const portfolioDocRef = doc(db, 'artifacts', appId, 'users', userId, 'portfolio', 'assets');
            await setDoc(portfolioDocRef, newPortfolio);

        } catch (error) {
            console.error("Error adding sample portfolio: ", error);
        }
    };
    
    // --- Render Logic ---
    return (
        <div className="bg-gray-900 text-white min-h-screen font-sans p-4 sm:p-6 lg:p-8">
            <div className="container mx-auto">
                <header className="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-8">
                    <div>
                        <h1 className="text-3xl font-bold text-white tracking-tight">React Crypto Tracker</h1>
                        <p className="text-gray-400 mt-1">Live portfolio powered by CoinGecko & Firebase.</p>
                        <p className="text-xs text-gray-500 mt-2">Last Updated: {lastUpdated}</p>
                    </div>
                    <div className="flex items-center mt-4 sm:mt-0">
                        <button onClick={() => setIsModalOpen(true)} className="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105">
                            Add Transaction
                        </button>
                        <button onClick={handleAddSamplePortfolio} className="ml-4 bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-all duration-300 transform hover:scale-105">
                            Add Sample Coins
                        </button>
                    </div>
                </header>

                <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
                    <StatCard title="Total Value" value={portfolioStats.totalValue.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })} change={{ value: portfolioStats.totalChangePercentage }}/>
                    <StatCard title="24h Change" value={`${portfolioStats.totalChangePercentage.toFixed(2)}%`} isCurrency={false}/>
                    <StatCard title="Top Gainer (24h)" value={portfolioStats.topGainer.name} isCurrency={false} />
                </div>

                <div className="bg-gray-800/50 backdrop-blur-sm rounded-2xl shadow-lg overflow-hidden border border-gray-700">
                    <div className="overflow-x-auto">
                        <table className="min-w-full">
                            <thead className="bg-gray-800/50">
                                <tr>
                                    {['Asset', 'Price', 'Holdings', 'Value', '24h Change'].map(head => (
                                        <th key={head} scope="col" className="px-6 py-4 text-left text-xs font-medium text-gray-300 uppercase tracking-wider">{head}</th>
                                    ))}
                                </tr>
                            </thead>
                            <tbody>
                                {isLoading ? (
                                    <tr><td colSpan="5" className="text-center py-10 text-gray-400">Loading your portfolio...</td></tr>
                                ) : Object.keys(portfolio).length === 0 ? (
                                     <tr><td colSpan="5" className="text-center py-10 text-gray-400">Your portfolio is empty. Add a transaction to start.</td></tr>
                                ) : (
                                    Object.values(portfolio).map(asset => {
                                        const data = liveData[asset.id];
                                        const currentValue = data ? asset.quantity * data.current_price : 0;
                                        const change24h = data ? data.price_change_percentage_24h || 0 : 0;
                                        return (
                                            <tr key={asset.id} className="border-b border-gray-700 hover:bg-gray-800/60 transition-colors duration-200">
                                                <td className="px-6 py-4 whitespace-nowrap">
                                                    <div className="flex items-center">
                                                        {data && <img className="h-9 w-9 rounded-full mr-4" src={data.image} alt={data.name} />}
                                                        <div>
                                                            <div className="font-semibold">{asset.name}</div>
                                                            <div className="text-sm text-gray-400">{asset.symbol.toUpperCase()}</div>
                                                        </div>
                                                    </div>
                                                </td>
                                                <td className="px-6 py-4 whitespace-nowrap font-mono">${data ? data.current_price.toLocaleString() : '...'}</td>
                                                <td className="px-6 py-4 whitespace-nowrap font-mono">{asset.quantity.toLocaleString()}</td>
                                                <td className="px-6 py-4 whitespace-nowrap font-mono">${currentValue.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                                                <td className={`px-6 py-4 whitespace-nowrap font-semibold ${change24h >= 0 ? 'text-green-400' : 'text-red-400'}`}>
                                                    {change24h.toFixed(2)}%
                                                </td>
                                            </tr>
                                        );
                                    })
                                )}
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
            
            <TransactionModal 
                isOpen={isModalOpen}
                onClose={() => setIsModalOpen(false)}
                coins={coinList}
                onAddTransaction={handleAddTransaction}
            />
        </div>
    );
}



